# Copyright 2024 Xin Huang
#
# GNU General Public License v3.0
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, please see
#
#    https://www.gnu.org/licenses/gpl-3.0.en.html


import h5py
import multiprocessing
import os
import shutil
import numpy as np
from gaia.utils.simulators import DataSimulator
from gaia.utils.simulators import MsprimeSimulator
from gaia.utils.generators import PolymorphismDataGenerator
from gaia.utils.labelers import BinaryAlleleLabeler
from gaia.utils.preprocessors import GenotypeMatricesPreprocessor
from gaia.utils.multiprocessing import write_h5, write_tsv


class UNetTrainingDataSimulator(DataSimulator):
    """
    A simulator class that integrates simulation, labeling, and data preprocessing
    for training U-Net models.

    """

    def __init__(
        self,
        demo_model_file: str,
        nref: int,
        ntgt: int,
        ref_id: str,
        tgt_id: str,
        src_id: str,
        ploidy: int,
        seq_len: int,
        mut_rate: float,
        rec_rate: float,
        output_prefix: str,
        output_dir: str,
        output_h5: bool,
        is_phased: bool,
        is_sorted: bool,
        keep_sim_data: bool,
        num_polymorphisms: int,
        num_upsamples: int,
    ):
        """
        Initializes a new instance of the UNetTrainingDataSimulator class.

        Parameters
        ----------
        demo_model_file : str
            Path to the demographic model file defining the simulation parameters.
        nref : int
            Number of samples in the reference population.
        ntgt : int
            Number of samples in the target population.
        ref_id : str
            Identifier for the reference population in the demographic model.
        tgt_id : str
            Identifier for the target population in the demographic model.
        src_id : str
            Identifier for the source population in the demographic model.
        ploidy : int
            Ploidy of the samples; typically 2 for diploid organisms.
        seq_len : int
            Length of the simulated sequence, in base pairs.
        mut_rate : float
            Mutation rate per base pair per generation.
        rec_rate : float
            Recombination rate per base pair per generation.
        output_prefix : str
            Prefix for the output files generated by the simulation.
        output_dir : str
            Directory where the output files will be stored.
        output_h5 : bool
            If True, output will be saved in HDF5 format. Otherwise, output will be saved in TSV format.
        is_phased : bool
            Indicates whether the simulated genomic data is phased.
        is_sorted : bool
            Indicates whether the simulated data should be sorted.
        keep_sim_data : bool
            If True, intermediate simulation data will be retained for further analysis.
        num_polymorphisms : int
            Number of polymorphic sites to simulate.
        num_upsamples : int
            Number of samples after upsampling to generate.

        Notes
        -----
        The output file will be created in the specified directory, with either a `.h5` or `.tsv` extension
        depending on the value of `output_h5`. If `output_h5` is True, an empty HDF5 file will be initialized.
        Otherwise, a TSV file will be created with appropriate headers.

        """

        self.simulator = MsprimeSimulator(
            demo_model_file=demo_model_file,
            nref=nref,
            ntgt=ntgt,
            ref_id=ref_id,
            tgt_id=tgt_id,
            src_id=src_id,
            ploidy=ploidy,
            seq_len=seq_len,
            mut_rate=mut_rate,
            rec_rate=rec_rate,
            output_prefix=output_prefix,
            output_dir=output_dir,
            is_phased=is_phased,
        )

        self.labeler = BinaryAlleleLabeler(
            ploidy=ploidy,
            is_phased=is_phased,
            num_polymorphisms=num_polymorphisms,
        )

        self.ploidy = ploidy
        self.is_phased = is_phased
        self.is_sorted = is_sorted
        self.keep_sim_data = keep_sim_data
        self.num_polymorphisms = num_polymorphisms
        self.num_upsamples = num_upsamples
        self.output_h5 = output_h5

        os.makedirs(output_dir, exist_ok=True)
        if self.output_h5:
            self.output = os.path.join(output_dir, f"{output_prefix}.h5")
            with h5py.File(self.output, "w") as f:
                pass
        else:
            self.output = os.path.join(output_dir, f"{output_prefix}.tsv")
            with open(self.output, "w") as f:
                f.write(
                    "Chromosome\t"
                    + "Start\t"
                    + "End\t"
                    + "Position\t"
                    + "Position_index\t"
                    + "Forward_relative_position\t"
                    + "Backward_relative_position\t"
                    + "Ref_sample\t"
                    + "Ref_genotype\t"
                    + "Tgt_sample\t"
                    + "Tgt_genotype\t"
                    + "Replicate\t"
                    + "Seed\n"
                )

    def run(self, rep: int = None, seed: int = None, **kwargs) -> None:
        """
        Executes the simulation and preprocessing pipeline for the U-Net model.

        Parameters
        ----------
        rep : int, optional
            The replicate number for the simulation run. If not provided, a default value is used.
        seed : int, optional
            The random seed for reproducibility. If not provided, a default value is used.

        """

        file_paths = self.simulator.run(rep=rep, seed=seed)[0]

        labels = self.labeler.run(
            vcf_file=file_paths["vcf_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            true_tract_file=file_paths["bed_file"],
            rep=rep,
        )

        polymorphism_data_generator = PolymorphismDataGenerator(
            vcf_file=file_paths["vcf_file"],
            ref_ind_file=file_paths["ref_ind_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            chr_name="1",
            random_polymorphisms=True,
            num_polymorphisms=self.num_polymorphisms,
            num_upsamples=self.num_upsamples,
            ploidy=self.ploidy,
            is_phased=self.is_phased,
            seed=seed,
        )

        preprocessor = GenotypeMatricesPreprocessor(
            ref_ind_file=file_paths["ref_ind_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            ref_rdm_spl_idx=polymorphism_data_generator.ref_rdm_spl_idx,
            tgt_rdm_spl_idx=polymorphism_data_generator.tgt_rdm_spl_idx,
            is_sorted=self.is_sorted,
        )

        data_dict = preprocessor.run(
            **list(polymorphism_data_generator.get())[0],
        )[0]

        if rep is not None:
            data_dict["Replicate"] = rep
        if seed is not None:
            data_dict["Seed"] = seed

        tgt_labels = []
        for sample in data_dict["Tgt_sample"]:
            tgt_labels.append(labels[sample]["Label"][data_dict["Position_index"]])

        data_dict["Label"] = np.array(tgt_labels)

        self._output_res(
            file_name=self.output,
            output_h5=self.output_h5,
            group_name_prefix="unet.training",
            data_dict=data_dict,
            rep=rep,
            nfeature=kwargs["nfeature"],
            force_balanced=kwargs["force_balanced"],
            nintro=kwargs["nintro"],
            nnonintro=kwargs["nnonintro"],
            only_intro=kwargs["only_intro"],
            only_non_intro=kwargs["only_non_intro"],
            lock=kwargs["lock"],
        )

        if not self.keep_sim_data:
            shutil.rmtree(os.path.dirname(file_paths["vcf_file"]), ignore_errors=True)

    def _output_res(
        self,
        file_name: str,
        output_h5: bool,
        group_name_prefix: str,
        data_dict: dict,
        rep: int,
        nfeature: int,
        force_balanced: bool,
        nintro: multiprocessing.Value,
        nnonintro: multiprocessing.Value,
        only_intro: bool,
        only_non_intro: bool,
        lock: multiprocessing.Lock,
    ) -> None:
        """
        Outputs the data dictionary to a file in either HDF5 or TSV format.

        Parameters
        ----------
        file_name : str
            Path to the output file.
        output_h5 : bool
            Flag to determine if the output should be in HDF5 format.
        group_name_prefix : str
            Prefix for the group name in the HDF5 file.
        data_dict : dict
            Dictionary containing the data to be written to the file.
        rep : int
            Replicate number.
        nfeature : int
            Maximum number of features to write.
        force_balanced : bool
            Flag to enable balancing of introgressed and non-introgressed regions.
        nintro : multiprocessing.Value
            Shared counter for the number of introgressed regions.
        nnonintro : multiprocessing.Value
            Shared counter for the number of non-introgressed regions.
        only_intro : bool
            Flag to include only introgressed regions.
        only_non_intro : bool
            Flag to include only non-introgressed regions.
        lock : multiprocessing.Lock
            Lock for synchronizing multiprocessing operations.

        """

        label_sum = np.sum(data_dict["Label"])
        if only_intro and (label_sum == 0):
            return
        if only_non_intro and (label_sum != 0):
            return

        write_data = False

        with lock:
            if nintro.value + nnonintro.value < nfeature:
                if force_balanced:
                    if label_sum == 0 and nnonintro.value < int(nfeature / 2):
                        write_data = True
                        nnonintro.value += 1
                    elif label_sum != 0 and nintro.value < int(nfeature / 2) + 1:
                        write_data = True
                        nintro.value += 1
                else:
                    write_data = True
                    if label_sum == 0:
                        nnonintro.value += 1
                    if label_sum != 0:
                        nintro.value += 1

        if write_data:
            if output_h5:
                if rep is not None:
                    group_name = f"{group_name_prefix}.{rep}"
                else:
                    group_name = f"{group_name_prefix}"
                write_h5(
                    file_name=file_name,
                    group_name=group_name,
                    data_dict=data_dict,
                    lock=lock,
                )
            else:
                write_tsv(
                    file_name=file_name,
                    data_dict=data_dict,
                    lock=lock,
                )
